// Generated by Create API
// https://github.com/CreateAPI/CreateAPI
//
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation

/// A fine-tuned model created using ModelService.CreateTunedModel.
public struct TunedModel: Codable {
  /// Optional. A short description of this model.
  public var description: String?
  /// Optional. For Nucleus sampling. Nucleus sampling considers the smallest set of tokens whose probability sum is at least `top_p`. This value specifies default to be the one used by the base model while creating the model.
  public var topP: Float?
  /// Output only. The timestamp when this model was updated.
  public var updateTime: String?
  /// Tuning tasks that create tuned models.
  public var tuningTask: TuningTask?
  /// Tuned model as a source for training a new model.
  public var tunedModelSource: TunedModelSource?
  /// Optional. Controls the randomness of the output. Values can range over `[0.0,1.0]`, inclusive. A value closer to `1.0` will produce responses that are more varied, while a value closer to `0.0` will typically result in less surprising responses from the model. This value specifies default to be the one used by the base model while creating the model.
  public var temperature: Float?
  /// Output only. The timestamp when this model was created.
  public var createTime: String?
  /// Immutable. The name of the `Model` to tune. Example: `models/text-bison-001`
  public var baseModel: String?
  /// Output only. The tuned model name. A unique name will be generated on create. Example: `tunedModels/az2mb0bpw6i` If display_name is set on create, the id portion of the name will be set by concatenating the words of the display_name with hyphens and adding a random portion for uniqueness. Example: display_name = "Sentence Translator" name = "tunedModels/sentence-translator-u3b7m"
  public var name: String?
  /// Optional. For Top-k sampling. Top-k sampling considers the set of `top_k` most probable tokens. This value specifies default to be used by the backend while making the call to the model. This value specifies default to be the one used by the base model while creating the model.
  public var topK: Int32?
  /// Optional. The name to display for this model in user interfaces. The display name must be up to 40 characters including spaces.
  public var displayName: String?
  /// Output only. The state of the tuned model.
  public var state: State?

  /// Output only. The state of the tuned model.
  public enum State: String, Codable, CaseIterable {
    case stateUnspecified = "STATE_UNSPECIFIED"
    case creating = "CREATING"
    case active = "ACTIVE"
    case failed = "FAILED"
  }

  public init(description: String? = nil, topP: Float? = nil, updateTime: String? = nil, tuningTask: TuningTask? = nil, tunedModelSource: TunedModelSource? = nil, temperature: Float? = nil, createTime: String? = nil, baseModel: String? = nil, name: String? = nil, topK: Int32? = nil, displayName: String? = nil, state: State? = nil) {
    self.description = description
    self.topP = topP
    self.updateTime = updateTime
    self.tuningTask = tuningTask
    self.tunedModelSource = tunedModelSource
    self.temperature = temperature
    self.createTime = createTime
    self.baseModel = baseModel
    self.name = name
    self.topK = topK
    self.displayName = displayName
    self.state = state
  }

  public init(from decoder: Decoder) throws {
    let values = try decoder.container(keyedBy: StringCodingKey.self)
    self.description = try values.decodeIfPresent(String.self, forKey: "description")
    self.topP = try values.decodeIfPresent(Float.self, forKey: "topP")
    self.updateTime = try values.decodeIfPresent(String.self, forKey: "updateTime")
    self.tuningTask = try values.decodeIfPresent(TuningTask.self, forKey: "tuningTask")
    self.tunedModelSource = try values.decodeIfPresent(TunedModelSource.self, forKey: "tunedModelSource")
    self.temperature = try values.decodeIfPresent(Float.self, forKey: "temperature")
    self.createTime = try values.decodeIfPresent(String.self, forKey: "createTime")
    self.baseModel = try values.decodeIfPresent(String.self, forKey: "baseModel")
    self.name = try values.decodeIfPresent(String.self, forKey: "name")
    self.topK = try values.decodeIfPresent(Int32.self, forKey: "topK")
    self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
    self.state = try values.decodeIfPresent(State.self, forKey: "state")
  }

  public func encode(to encoder: Encoder) throws {
    var values = encoder.container(keyedBy: StringCodingKey.self)
    try values.encodeIfPresent(description, forKey: "description")
    try values.encodeIfPresent(topP, forKey: "topP")
    try values.encodeIfPresent(updateTime, forKey: "updateTime")
    try values.encodeIfPresent(tuningTask, forKey: "tuningTask")
    try values.encodeIfPresent(tunedModelSource, forKey: "tunedModelSource")
    try values.encodeIfPresent(temperature, forKey: "temperature")
    try values.encodeIfPresent(createTime, forKey: "createTime")
    try values.encodeIfPresent(baseModel, forKey: "baseModel")
    try values.encodeIfPresent(name, forKey: "name")
    try values.encodeIfPresent(topK, forKey: "topK")
    try values.encodeIfPresent(displayName, forKey: "displayName")
    try values.encodeIfPresent(state, forKey: "state")
  }
}
